"""
–û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –±–æ—Ç–∞ –¢–µ—Ö–Ω–æ–ú–∞—Ä–∫–µ—Ç.
"""

import json
import re
from pathlib import Path

from aiogram import F, Router
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import FSInputFile, Message
from sqlalchemy import or_

from constants import BrandGroups, IgnoreWords, Messages, SizeRanges
from context import context_manager
from openai_api import get_gpt_response
from repository import (
    category_repo,
    message_repo,
    product_repo,
    search_service,
    user_repo,
)
from utils import (
    format_products_list,
    get_category_by_keywords,
    get_products_id,
    handle_errors,
)

router = Router()


class OrderStates(StatesGroup):
    waiting_for_choice = State()
    waiting_for_contact = State()
    product_card = State()


@router.message(Command("start"))
@handle_errors
async def cmd_start(message: Message):
    categories = category_repo.get_all()
    cat_list = "\n".join([f"‚Ä¢ {cat.name}" for cat in categories])
    image_url = "images/hello_image.png"
    photo = FSInputFile(image_url)
    text = (
        "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –¢–µ—Ö–Ω–æ–ú–∞—Ä–∫–µ—Ç! üõí\n\n"
        "–Ø ‚Äî –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –∫–æ–º–ø–∞–Ω–∏–∏ ü§ñ. –ì–æ—Ç–æ–≤ –ø–æ–º–æ—á—å —Å –≤—ã–±–æ—Ä–æ–º —Ç–µ—Ö–Ω–∏–∫–∏, –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏–µ–π –ø–æ —Ç–æ–≤–∞—Ä–∞–º –∏ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ–º –∑–∞–∫–∞–∑–∞!\n\n"
        "–í –Ω–∞—à–µ–º –º–∞–≥–∞–∑–∏–Ω–µ –µ—Å—Ç—å —Ç–∞–∫–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:\n"
        f"{cat_list}\n\n"
        "–ß—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç? –ü–∏—à–∏—Ç–µ –ø—Ä—è–º–æ —Å—é–¥–∞! \n\n"
        "üì¶ –î–æ—Å—Ç–∞–≤–∫–∞ –ø–æ –†–§ | üí≥ –û–ø–ª–∞—Ç–∞ –æ–Ω–ª–∞–π–Ω/–Ω–∞–ª–∏—á–Ω—ã–º–∏ | üõ°Ô∏è –ì–∞—Ä–∞–Ω—Ç–∏—è 1 –≥–æ–¥\n"
        "\n–°–∞–π—Ç: https://technomarket.ru\n\n"
        "‚ö†Ô∏è –í–Ω–∏–º–∞–Ω–∏–µ: –±–æ—Ç —Ç–µ—Å—Ç–æ–≤—ã–π, —Ñ–æ—Ç–æ —Ç–æ–≤–∞—Ä–æ–≤ –Ω–µ –Ω–∞—Å—Ç–æ—è—â–∏–µ, –∑–∞–∫–∞–∑—ã –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è."
    )
    await message.answer_photo(photo, caption=text)


@router.message(Command("setcontext"))
@handle_errors
async def cmd_setcontext(message: Message):
    if message.text and len(message.text.split(maxsplit=1)) > 1:
        new_context = message.text.split(maxsplit=1)[1]
        context_manager.save_context(new_context)
        await message.answer(Messages.CONTEXT_UPDATED)
    else:
        await message.answer(Messages.CONTEXT_PROMPT)


@router.message(Command("resetcontext"))
@handle_errors
async def cmd_resetcontext(message: Message):
    context_manager.reset_context()
    await message.answer(Messages.CONTEXT_RESET)


@router.message(F.text)
async def handle_message(message: Message, state: FSMContext):
    current_state = await state.get_state()
    if current_state:
        return

    user_message = message.text or ""

    user = user_repo.get_or_create(
        message.from_user.id,
        message.from_user.username,
        message.from_user.first_name,
        message.from_user.last_name,
    )
    user_id = user.id
    extra = json.loads(user.extra_data) if user.extra_data else {}

    message_repo.save_message(user_id, "user", user_message)

    history_limit = 5
    history = message_repo.get_user_history(user_id, limit=history_limit)
    history_text = "\n".join([f"{m.role}: {m.message}" for m in history])

    saved_params = extra.get("search_params", {})
    context = f"{context_manager.get_context()}\n\n–ò—Å—Ç–æ—Ä–∏—è –æ–±—â–µ–Ω–∏—è:\n{history_text}"
    reply = await get_gpt_response(user_message, context)
    message_repo.save_message(user_id, "assistant", reply)

    search_params = None
    for line in reply.splitlines():
        if line.strip().lower().startswith("–ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞:"):
            search_params = line.strip()[len("–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞:") :].strip()
            break

    params = dict(saved_params) if saved_params else {}
    if search_params:
        for part in search_params.split(","):
            if "=" in part:
                k, v = part.split("=", 1)
                k = k.strip().lower()
                v = v.strip().lower()
                if v and v not in IgnoreWords.WORDS:
                    params[k] = v

    extra["search_params"] = params
    user_repo.update_extra_data(user, extra)

    KEY_PARAMS = [
        "—Ü–µ–Ω–∞",
        "–±—é–¥–∂–µ—Ç",
        "–±—Ä–µ–Ω–¥",
        "—Ü–≤–µ—Ç",
        "—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏",
        "—Ä–∞–∑–º–µ—Ä",
        "–º–æ–¥–µ–ª—å",
        "–æ–±—ä—ë–º",
        "–æ–ø–µ—Ä–∞—Ç–∏–≤–Ω–∞—è –ø–∞–º—è—Ç—å",
        "—ç–∫—Ä–∞–Ω",
        "—Ç–∏–ø",
    ]
    has_characteristics = any(
        k in params and params[k] and params[k] not in IgnoreWords.WORDS
        for k in KEY_PARAMS
    )

    if not has_characteristics:
        cleaned_reply = "\n".join(
            line
            for line in reply.splitlines()
            if not (
                line.strip().lower().startswith("–ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞:")
                or line.strip().lower().startswith("–∏–∑–≤–ª–µ—á—ë–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:")
            )
        ).strip()
        if cleaned_reply:
            await message.answer(cleaned_reply)
        return

    category_obj = None

    if (
        "–∫–∞—Ç–µ–≥–æ—Ä–∏—è" not in params
        or not params["–∫–∞—Ç–µ–≥–æ—Ä–∏—è"]
        or any(w in params["–∫–∞—Ç–µ–≥–æ—Ä–∏—è"] for w in IgnoreWords.WORDS)
    ):
        last_category = extra.get("last_category")
        if last_category:
            params["–∫–∞—Ç–µ–≥–æ—Ä–∏—è"] = last_category
        else:
            cat_from_history = get_category_by_keywords(history_text)
            if cat_from_history:
                params["–∫–∞—Ç–µ–≥–æ—Ä–∏—è"] = cat_from_history[0]
                extra["last_category"] = cat_from_history[0]

    if "–∫–∞—Ç–µ–≥–æ—Ä–∏—è" in params and not any(
        w in params["–∫–∞—Ç–µ–≥–æ—Ä–∏—è"] for w in IgnoreWords.WORDS
    ):
        category_obj = category_repo.get_by_name(params["–∫–∞—Ç–µ–≥–æ—Ä–∏—è"])
        if category_obj:
            extra["last_category"] = category_obj.name
            user_repo.update_extra_data(user, extra)

    filters = {"color": [], "brand": [], "spec": [], "price": []}

    if "—Ü–≤–µ—Ç" in params and not any(w in params["—Ü–≤–µ—Ç"] for w in IgnoreWords.WORDS):
        colors = [
            c.strip() for c in re.split(r"[,/]| –∏–ª–∏ | or ", params["—Ü–≤–µ—Ç"]) if c.strip()
        ]
        if colors:
            from database.models import Product

            filters["color"] = [
                or_(
                    Product.name.ilike(f"%{color}%"),
                    Product.description.ilike(f"%{color}%"),
                )
                for color in colors
            ]

    if "–±—Ä–µ–Ω–¥" in params and not any(w in params["–±—Ä–µ–Ω–¥"] for w in IgnoreWords.WORDS):
        brands = []
        for group, group_brands in BrandGroups.get_all_brands().items():
            if group in params["–±—Ä–µ–Ω–¥"]:
                brands.extend(group_brands)
        for b in re.split(r"[,/]| –∏–ª–∏ | or ", params["–±—Ä–µ–Ω–¥"]):
            b = b.strip()
            if b and b not in brands:
                brands.append(b.capitalize())
        if brands:
            from database.models import Product

            filters["brand"] = [Product.name.ilike(f"%{b}%") for b in brands]

    if "—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏" in params and not any(
        w in params["—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏"] for w in IgnoreWords.WORDS
    ):
        size_words = ["–º–∞–ª–µ–Ω—å–∫–∏–π", "—Å—Ä–µ–¥–Ω–∏–π", "–±–æ–ª—å—à–æ–π"]
        for size_word in size_words:
            if size_word in params["—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏"]:
                cat_name = params.get("–∫–∞—Ç–µ–≥–æ—Ä–∏—è", "")
                for key, ranges in SizeRanges.get_all_ranges().items():
                    if key in cat_name.lower():
                        for sz in ranges[size_word]:
                            from database.models import Product

                            filters["spec"].append(Product.name.ilike(f"%{sz}%"))
                break
        else:
            from database.models import Product

            filters["spec"].append(
                Product.description.ilike(f"%{params['—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏']}%")
            )

    if "—Ç–∏–ø" in params and not any(w in params["—Ç–∏–ø"] for w in IgnoreWords.WORDS):
        from database.models import Product

        filters["spec"].append(Product.name.ilike(f"%{params['—Ç–∏–ø']}%"))
        filters["spec"].append(Product.description.ilike(f"%{params['—Ç–∏–ø']}%"))

    if "—Ü–µ–Ω–∞" in params and not any(w in params["—Ü–µ–Ω–∞"] for w in IgnoreWords.WORDS):
        try:
            price = int(re.sub(r"\D", "", params["—Ü–µ–Ω–∞"]))
            from database.models import Product

            filters["price"] = [Product.price <= price]
        except Exception:
            pass

    category_id = category_obj.id if category_obj else None
    products, dropped_filters = search_service.smart_search(category_id, filters)

    if products:
        products_id = get_products_id(products)
        extra["last_products"] = [
            {
                "id": p.id,
                "name": p.name,
                "image_url": p.image_url,
                "desc": p.description,
                "price": p.price,
            }
            for p in products
        ]
        extra["last_products_id"] = products_id
        user_repo.update_extra_data(user, extra)

        products_text = format_products_list(products)

        if dropped_filters:
            dropped_text = f"\n\n‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç–æ–≤–∞—Ä—ã —Å–æ –≤—Å–µ–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏. –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω—ã: {', '.join(dropped_filters)}"
            products_text += dropped_text

        await message.answer(
            products_text
            + "\n\n–ï—Å–ª–∏ —Ç–æ–≤–∞—Ä –≤–∞—Å –∑–∞–∏–Ω—Ç–µ—Ä–µ—Å–æ–≤–∞–ª, –≤–≤–µ–¥–∏—Ç–µ –µ–≥–æ –Ω–æ–º–µ—Ä –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏."
        )
        await state.set_state(OrderStates.waiting_for_choice)
    else:
        context = f"{context_manager.get_context()}\n\n–ò—Å—Ç–æ—Ä–∏—è –æ–±—â–µ–Ω–∏—è:\n{history_text}\n\n–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞: {params}"
        fallback_reply = await get_gpt_response(user_message, context)
        message_repo.save_message(user_id, "assistant", fallback_reply)

        cleaned_fallback = "\n".join(
            line
            for line in fallback_reply.splitlines()
            if not (
                line.strip().lower().startswith("–ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞:")
                or line.strip().lower().startswith("–∏–∑–≤–ª–µ—á—ë–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:")
            )
        ).strip()

        if cleaned_fallback:
            await message.answer(cleaned_fallback)
        else:
            await message.answer(
                "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –Ω–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Ç–æ–≤–∞—Ä—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞."
            )


@router.message(F.text.regexp(r"(?i)—Ñ–æ—Ç–æ|–∫–∞—Ä—Ç–∏–Ω–∫–∞|photo|picture|–ø–æ–∫–∞–∂–∏|show"))
async def handle_any_photo_request(message: Message, state: FSMContext):
    user_message = message.text or ""
    user = user_repo.get_or_create(
        message.from_user.id,
        message.from_user.username,
        message.from_user.first_name,
        message.from_user.last_name,
    )
    extra = json.loads(user.extra_data) if user.extra_data else {}

    last_products = extra.get("last_products", [])
    if not last_products:
        await message.answer(
            "–°–Ω–∞—á–∞–ª–∞ –Ω–∞–π–¥–∏—Ç–µ —Ç–æ–≤–∞—Ä—ã, –∞ –∑–∞—Ç–µ–º –∑–∞–ø—Ä–æ—Å–∏—Ç–µ —Ñ–æ—Ç–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞."
        )
        return

    choice = re.sub(
        r"(?i)—Ñ–æ—Ç–æ|–∫–∞—Ä—Ç–∏–Ω–∫–∞|photo|picture|–ø–æ–∫–∞–∂–∏|show", "", user_message
    ).strip()
    if not choice:
        await message.answer(
            "–£–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä –∏–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞, —Ñ–æ—Ç–æ –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ —É–≤–∏–¥–µ—Ç—å."
        )
        return

    chosen = None
    try:
        num = int(choice)
        if 1 <= num <= len(last_products):
            chosen = last_products[num - 1]
    except ValueError:
        pass

    if not chosen:
        for prod in last_products:
            if prod["name"].lower() in choice or choice in prod["name"].lower():
                chosen = prod
                break

    if chosen:
        file_path = Path.cwd() / chosen["image_url"]
        if file_path.exists():
            photo = FSInputFile(str(file_path))
            caption = f"{chosen['name']} ‚Äî {chosen['price']}‚ÇΩ\n{chosen['desc']}"
            await message.answer_photo(
                photo,
                caption=caption
                + "\n\n–•–æ—Ç–∏—Ç–µ –æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑ –Ω–∞ —ç—Ç–æ—Ç —Ç–æ–≤–∞—Ä? –ù–∞–ø–∏—à–∏—Ç–µ '–æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑' –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º.",
            )
        else:
            await message.answer(
                f"{chosen['name']}\n–§–æ—Ç–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.\n{chosen['desc']}"
            )

        extra["current_product"] = chosen
        extra["current_product_list_id"] = extra.get("last_products_id")
        user_repo.update_extra_data(user, extra)
        await state.set_state(OrderStates.product_card)
    else:
        await message.answer(
            "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –∫–∞–∫–æ–π —Ç–æ–≤–∞—Ä –≤—ã –≤—ã–±—Ä–∞–ª–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∏–ª–∏ —Ç–æ—á–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤—ã–¥–∞—á–∏."
        )


@router.message(StateFilter(OrderStates.waiting_for_choice), F.text)
async def handle_product_choice(message: Message, state: FSMContext):
    user_message = message.text or ""
    user = user_repo.get_or_create(
        message.from_user.id,
        message.from_user.username,
        message.from_user.first_name,
        message.from_user.last_name,
    )
    extra = json.loads(user.extra_data) if user.extra_data else {}

    last_products = extra.get("last_products", [])
    if not last_products:
        await message.answer(
            "–°–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ —É—Å—Ç–∞—Ä–µ–ª. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫."
        )
        await state.clear()
        return

    chosen = None
    try:
        num = int(user_message)
        if 1 <= num <= len(last_products):
            chosen = last_products[num - 1]
    except ValueError:
        for prod in last_products:
            if (
                prod["name"].lower() in user_message.lower()
                or user_message.lower() in prod["name"].lower()
            ):
                chosen = prod
                break

    if chosen:
        file_path = Path.cwd() / chosen["image_url"]
        if file_path.exists():
            photo = FSInputFile(str(file_path))
            caption = f"{chosen['name']} ‚Äî {chosen['price']}‚ÇΩ\n{chosen['desc']}"
            await message.answer_photo(
                photo,
                caption=caption
                + "\n\n–•–æ—Ç–∏—Ç–µ –æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑ –Ω–∞ —ç—Ç–æ—Ç —Ç–æ–≤–∞—Ä? –ù–∞–ø–∏—à–∏—Ç–µ '–æ—Ñ–æ—Ä–º–∏—Ç—å –∑–∞–∫–∞–∑' –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º.",
            )
        else:
            await message.answer(
                f"{chosen['name']}\n–§–æ—Ç–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.\n{chosen['desc']}"
            )

        extra["current_product"] = chosen
        extra["current_product_list_id"] = extra.get("last_products_id")
        user_repo.update_extra_data(user, extra)
        await state.set_state(OrderStates.product_card)
    else:
        await message.answer(
            "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –∫–∞–∫–æ–π —Ç–æ–≤–∞—Ä –≤—ã –≤—ã–±—Ä–∞–ª–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –∏–ª–∏ —Ç–æ—á–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞ –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤—ã–¥–∞—á–∏."
        )


@router.message(StateFilter(OrderStates.product_card), F.text)
async def handle_product_card(message: Message, state: FSMContext):
    user_message = message.text or ""
    user = user_repo.get_or_create(
        message.from_user.id,
        message.from_user.username,
        message.from_user.first_name,
        message.from_user.last_name,
    )
    extra = json.loads(user.extra_data) if user.extra_data else {}
    current_product = extra.get("current_product")

    if not current_product:
        await message.answer(Messages.PRODUCT_NOT_FOUND)
        await state.clear()
        return

    user_message_lower = user_message.lower()

    if any(
        word in user_message_lower
        for word in ["—Ñ–æ—Ç–æ", "–∫–∞—Ä—Ç–∏–Ω–∫–∞", "photo", "picture", "–ø–æ–∫–∞–∂–∏", "show"]
    ):
        if current_product["image_url"].startswith("images/"):
            file_path = Path.cwd() / current_product["image_url"]
            if file_path.exists():
                photo = FSInputFile(str(file_path))
                await message.answer_photo(photo, caption=current_product["name"])
            else:
                await message.answer(
                    Messages.PHOTO_NOT_FOUND.format(name=current_product["name"])
                )
        else:
            await message.answer_photo(
                current_product["image_url"], caption=current_product["name"]
            )

    elif any(
        word in user_message_lower
        for word in [
            "—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏",
            "—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞",
            "–æ–ø–∏—Å–∞–Ω–∏–µ",
            "–ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏",
            "–¥–µ—Ç–∞–ª–∏",
            "specs",
            "specifications",
        ]
    ):
        await message.answer(
            f"üìã –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ {current_product['name']}:\n\n{current_product['desc']}\n\nüí∞ –¶–µ–Ω–∞: {current_product['price']}‚ÇΩ"
        )

    elif any(
        word in user_message_lower
        for word in ["—Ü–µ–Ω–∞", "—Å—Ç–æ–∏–º–æ—Å—Ç—å", "price", "cost", "—Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç"]
    ):
        await message.answer(
            f"üí∞ –¶–µ–Ω–∞ {current_product['name']}: {current_product['price']}‚ÇΩ"
        )

    elif any(
        word in user_message_lower
        for word in [
            "–∑–∞–∫–∞–∑",
            "–∫—É–ø–∏—Ç—å",
            "–ø—Ä–∏–æ–±—Ä–µ—Å—Ç–∏",
            "–æ—Ñ–æ—Ä–º–∏—Ç—å",
            "order",
            "buy",
            "purchase",
        ]
    ):
        await message.answer(
            f"üõí –û—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ –∑–∞–∫–∞–∑–∞ –Ω–∞ {current_product['name']}\n\n"
            f"–î–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞—à–∏–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º:\n"
            f"üìû –¢–µ–ª–µ—Ñ–æ–Ω: +7 (800) 555-0123\n"
            f"üìß Email: order@technomarket.ru\n"
            f"üí¨ Telegram: @technomarket_support\n\n"
            f"–ò–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ —Å–≤–æ–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞, –∏ –º—ã –ø–µ—Ä–µ–∑–≤–æ–Ω–∏–º –≤–∞–º –≤ —Ç–µ—á–µ–Ω–∏–µ 15 –º–∏–Ω—É—Ç."
        )
        await state.set_state(OrderStates.waiting_for_contact)

    elif any(
        word in user_message_lower
        for word in [
            "–Ω–∞–∑–∞–¥",
            "—Å–ø–∏—Å–æ–∫",
            "–¥—Ä—É–≥–∏–µ",
            "–µ—â–µ",
            "back",
            "list",
            "other",
            "more",
        ]
    ):
        await message.answer(Messages.CHOOSE_ANOTHER)
        await state.clear()

    else:
        context = f"""–¢—ã ‚Äî –∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç –º–∞–≥–∞–∑–∏–Ω–∞ "–¢–µ—Ö–Ω–æ–ú–∞—Ä–∫–µ—Ç". –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∑–∞–¥–∞–µ—Ç –≤–æ–ø—Ä–æ—Å –æ —Ç–æ–≤–∞—Ä–µ:

–¢–æ–≤–∞—Ä: {current_product['name']}
–û–ø–∏—Å–∞–Ω–∏–µ: {current_product['desc']}
–¶–µ–Ω–∞: {current_product['price']}‚ÇΩ

–í–æ–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {user_message}

–û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ –¥–µ–ª—É. –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–ø—Ä–∞—à–∏–≤–∞–µ—Ç –æ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞—Ö, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —É–∫–∞–∑–∞–Ω—ã –≤ –æ–ø–∏—Å–∞–Ω–∏–∏, –≤–µ–∂–ª–∏–≤–æ —Å–æ–æ–±—â–∏, —á—Ç–æ —ç—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –∏ –ø—Ä–µ–¥–ª–æ–∂–∏ —Å–≤—è–∑–∞—Ç—å—Å—è —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π."""

        reply = await get_gpt_response(user_message, context)
        if not reply or not reply.strip():
            await message.answer(Messages.NO_ANSWER)
        else:
            await message.answer(reply)
